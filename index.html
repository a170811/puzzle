<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>ç²¾ç·»ç‰ˆç©æœ¨æ‹¼åœ–æ±‚è§£å™¨</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --wood-dark: #5d3a1a;
            --wood-light: #c09f7a;
            --border-color: #8b4513;
        }

        body { font-family: 'Segoe UI', sans-serif; background-color: var(--bg-color); display: flex; flex-direction: column; align-items: center; padding: 20px; user-select: none; }
        
        /* æ§åˆ¶å€ */
        .controls { margin-bottom: 20px; display: flex; gap: 15px; align-items: flex-start; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        button { padding: 12px 24px; font-size: 15px; font-weight: bold; cursor: pointer; border: none; border-radius: 8px; color: white; transition: all 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #solveBtn { background: #27ae60; }
        #solveBtn:hover { background: #2ecc71; transform: translateY(-1px); }
        #solveBtn:disabled { background: #bdc3c7; cursor: wait; }
        #resetBtn { background: #e67e22; }
        .hint { background: white; padding: 12px 20px; border-radius: 10px; font-size: 13px; color: #444; border-left: 5px solid var(--border-color); line-height: 1.6; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }

        /* æ‰‹æ©Ÿæ“ä½œæŒ‰éˆ• */
        .mobile-controls { display: none; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap; }
        .mobile-controls.active { display: flex; }
        .mobile-btn { padding: 15px 25px; font-size: 16px; font-weight: bold; cursor: pointer; border: none; border-radius: 10px; color: white; transition: all 0.2s; box-shadow: 0 3px 8px rgba(0,0,0,0.2); touch-action: manipulation; }
        .rotate-btn { background: #3498db; }
        .rotate-btn:active { background: #2980b9; transform: scale(0.95); }
        .flip-btn { background: #9b59b6; }
        .flip-btn:active { background: #8e44ad; transform: scale(0.95); }
        .cancel-btn { background: #e74c3c; }
        .cancel-btn:active { background: #c0392b; transform: scale(0.95); }

        @media (max-width: 768px) {
            .hint { font-size: 12px; padding: 10px 15px; }
            .controls { flex-direction: column; gap: 10px; }
            .tray { padding: 15px; gap: 15px; }
        }

        /* æœ¨ç›’å®¹å™¨ */
        .board-wrapper { padding: 12px; background: var(--wood-light); border: 12px solid var(--border-color); border-radius: 12px; box-shadow: 0 15px 35px rgba(0,0,0,0.3); margin-bottom: 30px; }
        .grid { display: grid; grid-template-columns: repeat(10, 40px); grid-template-rows: repeat(6, 40px); gap: 1px; background-color: var(--wood-dark); border: 1px solid var(--wood-dark); }
        .cell { width: 40px; height: 40px; background-color: #fffbe6; transition: background 0.2s; cursor: pointer; position: relative; }
        .cell:hover { background-color: #fff0b3; }
        .cell.occupied { border: 1px solid rgba(255,255,255,0.25); box-sizing: border-box; }

        /* é›¶ä»¶ç›¤å„ªåŒ– */
        .tray { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; width: 100%; max-width: 950px; padding: 25px; background: rgba(255,255,255,0.7); border-radius: 15px; border: 1px dashed #ccc; }
        .piece-preview { cursor: pointer; display: grid; gap: 1px; padding: 4px; border-radius: 4px; border: 2px solid transparent; transition: all 0.2s; }
        .piece-preview:hover { background: rgba(0,0,0,0.03); }
        .piece-preview.selected { border-color: #e74c3c; background: #fff; box-shadow: 0 0 12px rgba(231,76,60,0.3); }

        .mini-cell { width: 16px; height: 16px; box-sizing: border-box; }
        .mini-cell.filled { border: 1px solid rgba(0,0,0,0.1); border-radius: 2px; }

        /* ç©æœ¨é¡è‰² - æ ¹æ“šåœ–ç‰‡é¢¨æ ¼ */
        .p_P { background-color: #a349a4; } /* ç´«è‰² */
        .p_F { background-color: #00a2e8; } /* è—è‰² */
        .p_L { background-color: #ff7f27; } /* æ©˜è‰² */
        .p_T { background-color: #4b0082; } /* æ·±ç´« */
        .p_W { background-color: #22b14c; } /* ç¶ è‰² */
        .p_U { background-color: #fff200; } /* é»ƒè‰² */
        .p_V { background-color: #b5e61d; } /* æ·ºç¶  */
        .p_Z { background-color: #ed1c24; } /* ç´…è‰² */
        .p_I { background-color: #ff4500; } /* é•·æ¢ç´… */
        .p_Y { background-color: #ffd700; } /* å´é‚Šé»ƒ */
        .p_X { background-color: #7f7f7f; } /* ç°è‰² */
        .p_N { background-color: #3f48cc; } /* æ·±è— */
    </style>
</head>
<body>

    <div class="controls">
        <div class="btn-group">
            <button id="solveBtn">æ ¹æ“šç¾ç‹€å®Œæˆæ‹¼åœ–</button>
            <button id="resetBtn">æ¸…ç©ºé‡è¨­</button>
        </div>
        <div class="hint">
            <b>æ“ä½œæŒ‡å—ï¼š</b><br>
            â€¢ <b>é»é¸</b>ä¸‹æ–¹ç©æœ¨ï¼Œåœ¨æœ¨ç›’<b>é»æ“Š</b>æ”¾ç½®ã€‚<br>
            â€¢ é›»è…¦ï¼šæŒ‰ <b>R</b> éµæ—‹è½‰ï¼Œ<b>F</b> éµç¿»è½‰ã€‚<br>
            â€¢ æ‰‹æ©Ÿï¼šé¸ä¸­ç©æœ¨å¾Œä½¿ç”¨ä¸‹æ–¹æŒ‰éˆ•æ“ä½œã€‚<br>
            â€¢ <b>é•·æŒ‰</b>æœ¨ç›’å…§çš„ç©æœ¨å¯å°‡å…¶å–ä¸‹ã€‚
        </div>
    </div>

    <div class="mobile-controls" id="mobileControls">
        <button class="mobile-btn rotate-btn" id="rotateBtn">ğŸ”„ æ—‹è½‰</button>
        <button class="mobile-btn flip-btn" id="flipBtn">ğŸ” ç¿»è½‰</button>
        <button class="mobile-btn cancel-btn" id="cancelBtn">âœ– å–æ¶ˆé¸æ“‡</button>
    </div>

    <div class="board-wrapper">
        <div id="board" class="grid"></div>
    </div>

    <div id="tray" class="tray"></div>

    <footer style="margin-top: 30px; padding: 20px; text-align: center; color: #666; font-size: 13px; background: rgba(255,255,255,0.5); border-radius: 10px; max-width: 600px;">
        <p style="margin: 0;">ğŸ“š åƒè€ƒä¾†æºï¼š<a href="https://www.threads.com/@ee_days/post/DS2UCH6D4X6?xmt=AQF0fSkbIidu2mb58qq7QfUTqBU4j7ka5CoOys5fv412gOMwuU8HasAGzXLueJ1TKC5SmNSDnw&slof=1" target="_blank" style="color: #3498db; text-decoration: none;">@ee_days on Threads</a></p>
    </footer>

<script>
// å½¢ç‹€æ•¸æ“š (åš´æ ¼éµå®ˆä½¿ç”¨è€…ç¢ºèªçš„çŸ©é™£)
const SHAPES_DATA = {
    P:[[1,1],[1,1],[1,0]], F:[[0,1,1],[1,1,0],[0,1,0]], L:[[1,0],[1,0],[1,0],[1,1]],
    T:[[1,1,1],[0,1,0],[0,1,0]], W:[[1,0,0],[1,1,0],[0,1,1]], U:[[1,0,1],[1,1,1]],
    V:[[1,0,0],[1,0,0],[1,1,1]], Z:[[1,1,0],[0,1,0],[0,1,1]], I:[[1,1,1,1,1]],
    Y:[[1,1,1,1],[0,1,0,0]], X:[[0,1,0],[1,1,1],[0,1,0]], N:[[1,1,0,0],[0,1,1,1]]
};

const ROWS = 6, COLS = 10;
let boardState = Array(ROWS).fill(0).map(() => Array(COLS).fill(0));
let usedPieces = new Set();
let selectedPieceId = null;
let currentVariant = null;
let longPressTimer = null;

// å·¥å…·å‡½å¼
const rotate = (m) => m[0].map((_, i) => m.map(row => row[i]).reverse());
const flip = (m) => m.map(row => [...row].reverse());
const getVariants = (shape) => {
    let vars = [];
    let curr = shape;
    for(let i=0; i<4; i++) { vars.push(curr); vars.push(flip(curr)); curr = rotate(curr); }
    let seen = new Set();
    return vars.filter(v => {
        let s = JSON.stringify(v);
        if(seen.has(s)) return false;
        seen.add(s); return true;
    });
};

const PIECE_VARIANTS = {};
Object.keys(SHAPES_DATA).forEach(id => PIECE_VARIANTS[id] = getVariants(SHAPES_DATA[id]));

// UI æ¸²æŸ“
function renderTray() {
    const tray = document.getElementById('tray');
    tray.innerHTML = '';
    Object.keys(SHAPES_DATA).forEach(id => {
        if (usedPieces.has(id)) return;
        const div = document.createElement('div');
        div.className = `piece-preview ${selectedPieceId === id ? 'selected' : ''}`;
        const shape = (selectedPieceId === id) ? currentVariant : SHAPES_DATA[id];
        
        div.style.gridTemplateColumns = `repeat(${shape[0].length}, 16px)`;
        shape.flat().forEach(v => {
            const c = document.createElement('div');
            c.className = 'mini-cell' + (v ? ` filled p_${id}` : '');
            div.appendChild(c);
        });
        div.onclick = () => {
            selectedPieceId = (selectedPieceId === id) ? null : id;
            currentVariant = selectedPieceId ? SHAPES_DATA[id] : null;
            updateMobileControls();
            renderTray();
        };
        tray.appendChild(div);
    });
}

function updateMobileControls() {
    const mobileControls = document.getElementById('mobileControls');
    if (selectedPieceId) {
        mobileControls.classList.add('active');
    } else {
        mobileControls.classList.remove('active');
    }
}

function renderBoard() {
    const board = document.getElementById('board');
    board.innerHTML = '';
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell' + (boardState[r][c] ? ' occupied p_' + boardState[r][c] : '');
            cell.onclick = () => placeAt(r, c);
            cell.oncontextmenu = (e) => { e.preventDefault(); removeAt(r, c); };
            
            // æ‰‹æ©Ÿé•·æŒ‰æ”¯æ´
            cell.ontouchstart = (e) => {
                if (boardState[r][c]) {
                    longPressTimer = setTimeout(() => {
                        removeAt(r, c);
                        longPressTimer = null;
                    }, 500);
                }
            };
            cell.ontouchend = (e) => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    if (!boardState[r][c]) {
                        placeAt(r, c);
                    }
                }
            };
            cell.ontouchmove = () => {
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
            };
            
            board.appendChild(cell);
        }
    }
}

// é‚è¼¯è™•ç†
function canPlace(grid, v, r, c) {
    for(let i=0; i<v.length; i++) {
        for(let j=0; j<v[i].length; j++) {
            if(v[i][j]) {
                const tr = r+i, tc = c+j;
                if(tr>=ROWS || tc>=COLS || tr<0 || tc<0 || grid[tr][tc]!==0) return false;
            }
        }
    }
    return true;
}

function applyPiece(grid, v, r, c, val) {
    for(let i=0; i<v.length; i++) for(let j=0; j<v[i].length; j++) if(v[i][j]) grid[r+i][c+j] = val;
}

function placeAt(r, c) {
    if(!selectedPieceId) return;
    if(canPlace(boardState, currentVariant, r, c)) {
        applyPiece(boardState, currentVariant, r, c, selectedPieceId);
        usedPieces.add(selectedPieceId);
        selectedPieceId = null; currentVariant = null;
        updateMobileControls();
        renderBoard(); renderTray();
    }
}

function removeAt(r, c) {
    const id = boardState[r][c];
    if(!id) return;
    for(let i=0; i<6; i++) for(let j=0; j<10; j++) if(boardState[i][j]===id) boardState[i][j]=0;
    usedPieces.delete(id);
    updateMobileControls();
    renderBoard(); renderTray();
}

// æ±‚è§£å™¨
function solve(grid, ids) {
    if(ids.length === 0) return grid;
    let r = -1, c = -1;
    for(let i=0; i<6; i++) {
        for(let j=0; j<10; j++) if(grid[i][j]===0) { r=i; c=j; break; }
        if(r!==-1) break;
    }
    if(r===-1) return grid;

    for(let i=0; i<ids.length; i++) {
        const id = ids[i];
        for(const v of PIECE_VARIANTS[id]) {
            let vR = -1, vC = -1;
            for(let row=0; row<v.length; row++) {
                let col = v[row].indexOf(1);
                if(col!==-1) { vR=row; vC=col; break; }
            }
            if(canPlace(grid, v, r-vR, c-vC)) {
                applyPiece(grid, v, r-vR, c-vC, id);
                const res = solve(grid, [...ids.slice(0,i), ...ids.slice(i+1)]);
                if(res) return res;
                applyPiece(grid, v, r-vR, c-vC, 0);
            }
        }
    }
    return null;
}

document.getElementById('solveBtn').onclick = function() {
    this.disabled = true;
    this.innerText = "è¨ˆç®—ä¸­...";
    setTimeout(() => {
        const rem = Object.keys(SHAPES_DATA).filter(id => !usedPieces.has(id));
        const res = solve(JSON.parse(JSON.stringify(boardState)), rem);
        if(res) {
            boardState = res;
            usedPieces = new Set(Object.keys(SHAPES_DATA));
            renderBoard(); renderTray();
        } else {
            alert("ç›®å‰æ ¼å±€ç„¡è§£ï¼è«‹èª¿æ•´ä½ç½®æˆ–ç¢ºä¿æ²’æœ‰ç•™ä¸‹æ­»è§’ç©ºé–“ã€‚");
        }
        this.disabled = false;
        this.innerText = "æ ¹æ“šç¾ç‹€å®Œæˆæ‹¼åœ–";
    }, 50);
};

document.getElementById('resetBtn').onclick = () => location.reload();

window.onkeydown = (e) => {
    if(!selectedPieceId) return;
    if(e.key.toLowerCase()==='r') currentVariant = rotate(currentVariant);
    if(e.key.toLowerCase()==='f') currentVariant = flip(currentVariant);
    renderTray();
};

// æ‰‹æ©Ÿæ“ä½œæŒ‰éˆ•
document.getElementById('rotateBtn').onclick = () => {
    if(!selectedPieceId) return;
    currentVariant = rotate(currentVariant);
    renderTray();
};

document.getElementById('flipBtn').onclick = () => {
    if(!selectedPieceId) return;
    currentVariant = flip(currentVariant);
    renderTray();
};

document.getElementById('cancelBtn').onclick = () => {
    selectedPieceId = null;
    currentVariant = null;
    updateMobileControls();
    renderTray();
};

renderBoard(); renderTray();
</script>
</body>
</html>
